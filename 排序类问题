leetcode 373 查找和最小的 K 对数字
https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/
对priority_queue< pair<int,int> > pq; 的排序
        auto cmp = [&nums1, &nums2](const pair<int, int> & a, const pair<int, int> & b) {
            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];  //最小的在顶部，换成“<”后最大的在顶部
        };
后续写做
priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);


https://leetcode-cn.com/problems/k-highest-ranked-items-within-a-price-range/submissions/
价格范围内最高排名的 K 样物品
利用结构体排序
    struct node{
        int dis,row,column,price;
        bool operator < (node &b) {
            if(dis!=b.dis) return dis<b.dis;
            if(price!=b.price) return price<b.price;
            if(row!=b.row) return row<b.row;
            return column<b.column;
        }
    };
在类定义运算符时自带一个

leetcode 432. 全 O(1) 的数据结构
插入元素为结构体时重载运算符
    typedef struct st{
        string s;
        int cnt;
        /*bool operator < (st &b) {
            return cnt < b.cnt ; 
        }*/
        friend bool operator<(const st &a, const st &b) {
            if(a.cnt == b.cnt) {
                return a.s < b.s;
            }
            return a.cnt < b.cnt;
        }
    }st;
