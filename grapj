    //拓扑排序 例题：课程表
    //返回拓扑数组，如果成环，返回空序列
    vector<vector<int>> edge;
    vector<int> vis,res;
    bool flag=true;
    void dfs(int u){
        vis[u]=1;
        for(int i=0;i<edge[u].size();i++){
            if(!vis[edge[u][i]]){
                dfs(edge[u][i]);
                if(!flag){
                    return ;
                }
            }
            else if(vis[edge[u][i]]==1){
                flag=false;
                return ;
            }
        }
        vis[u]=2;
        res.push_back(u);
    }
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        flag=true;
        res.clear();
        edge.clear();
        edge.resize(numCourses);
        vis.clear();
        vis.resize(numCourses,0);
        for(const auto &info:prerequisites){
            edge[info[1]].push_back(info[0]);
        }
        for(int i=1;i<numCourses&&flag;i++){
            if(!vis[i]){
                dfs(i);
            }
        }
        if(!flag) return {};
        return res;
    }
二分图：
        def is_bipartite(x: int, c: int) -> bool:  # 二分图判定，原理见视频讲解
            nodes.append(x)
            color[x] = c
            for y in g[x]:
                if color[y] == c or color[y] == 0 and not is_bipartite(y, -c):
                    return False
            return True

        ans = 0
        for i, c in enumerate(color):
            if c: continue
            nodes = []
            if not is_bipartite(i, 1): return -1  # 如果不是二分图（有奇环），则无法分组
        return ans
